C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE RELAY
OBJECT MODULE PLACED IN ..\Output\Relay.obj
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE ..\Source\Device_Driver\Relay.c OPTIMIZE(9,SPEED) BROWSE INCDIR(..\Source\A
                    -pplication;..\Source\Device_Driver;..\Source\System;D:\Keil\C51\INC\STC) DEBUG OBJECTEXTEND PRINT(.\Listings\Relay.lst) 
                    -TABS(2) OBJECT(..\Output\Relay.obj)

line level    source

   1          #include "Config.h"
   2          #include "Relay.h"
   3          
   4          extern u16 NowTime;  //引用时间
   5          
   6          /*需要在设置菜单设置的变量*/
   7          
   8          /*用于记录端口是否被触发*/
   9          //Pin12输出响应标志,任务响应后清除
  10          bit Pin12 = 0; 
  11          bit Pin13 = 0; 
  12          bit Pin14 = 0;
  13          bit Pin15 = 0;
  14          bit Pin16 = 0;
  15          bit Pin17 = 0;
  16          
  17          bit Pin20 = 0;
  18          bit Pin21 = 0;
  19          bit Pin22 = 0;
  20          bit Pin23 = 0;
  21          bit Pin24 = 0;
  22          
  23          bit Pin35 = 0;
  24          bit Pin36 = 0;
  25          bit Pin37 = 0;
  26          
  27          /*端口的触发模式*/
  28          /*触发模式（0为自锁模式）（1为立即模式）*/
  29          //自锁模式：按键按下，释放才会更新任务状态
  30          //立即模式：按键按下，立刻更新任务状态，按键释放才可重新更新
  31          bdata u16 Pin_Trigger_Mode;
  32          
  33          sbit Pin10_Trigger_Mode = Pin_Trigger_Mode^0;
  34          sbit Pin11_Trigger_Mode = Pin_Trigger_Mode^1;
  35          
  36          sbit Pin12_Trigger_Mode = Pin_Trigger_Mode^2;
  37          sbit Pin13_Trigger_Mode = Pin_Trigger_Mode^3;
  38          sbit Pin14_Trigger_Mode = Pin_Trigger_Mode^4;
  39          sbit Pin15_Trigger_Mode = Pin_Trigger_Mode^5;
  40          sbit Pin16_Trigger_Mode = Pin_Trigger_Mode^6;
  41          sbit Pin17_Trigger_Mode = Pin_Trigger_Mode^7;
  42          
  43          sbit Pin20_Trigger_Mode = Pin_Trigger_Mode^8;
  44          sbit Pin21_Trigger_Mode = Pin_Trigger_Mode^9;
  45          sbit Pin22_Trigger_Mode = Pin_Trigger_Mode^10;
  46          sbit Pin23_Trigger_Mode = Pin_Trigger_Mode^11;
  47          sbit Pin24_Trigger_Mode = Pin_Trigger_Mode^12;
  48          
  49          sbit Pin35_Trigger_Mode = Pin_Trigger_Mode^13;
  50          sbit Pin36_Trigger_Mode = Pin_Trigger_Mode^14;
  51          sbit Pin37_Trigger_Mode = Pin_Trigger_Mode^15;
  52          
  53          /*
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 2   

  54          bit Pin10_Trigger_Mode = 0;
  55          bit Pin11_Trigger_Mode = 0;
  56          
  57          bit Pin12_Trigger_Mode = 1;
  58          bit Pin13_Trigger_Mode = 1;
  59          bit Pin14_Trigger_Mode = 0;
  60          bit Pin15_Trigger_Mode = 0;
  61          bit Pin16_Trigger_Mode = 0;
  62          bit Pin17_Trigger_Mode = 0;
  63          
  64          bit Pin20_Trigger_Mode = 1;
  65          bit Pin21_Trigger_Mode = 1;
  66          bit Pin22_Trigger_Mode = 1;
  67          bit Pin23_Trigger_Mode = 1;
  68          bit Pin24_Trigger_Mode = 1;
  69          
  70          bit Pin35_Trigger_Mode = 0;
  71          bit Pin36_Trigger_Mode = 0;
  72          bit Pin37_Trigger_Mode = 0;
  73          */
  74          
  75          /*端口外部的模拟按键*/
  76          /*0代表按键状态还没有按下，1代表按键处于按下的状态*/
  77          bit Pin10_Key = 0;
  78          bit Pin11_Key = 0;
  79          
  80          bit Pin12_Key = 0;
  81          bit Pin13_Key = 0;
  82          bit Pin14_Key = 0;
  83          bit Pin15_Key = 0;
  84          bit Pin16_Key = 0;
  85          bit Pin17_Key = 0;
  86          
  87          bit Pin20_Key = 0;
  88          bit Pin21_Key = 0;
  89          bit Pin22_Key = 0;
  90          bit Pin23_Key = 0;
  91          bit Pin24_Key = 0;
  92          
  93          bit Pin35_Key = 0;
  94          bit Pin36_Key = 0;
  95          bit Pin37_Key = 0;
  96          
  97          /*输入模式时作为端口触发更新任务号*/ 
  98          /*输出模式时选择关联任务号*/
  99          /*端口模式（0为输入模式）（1为输出模式）*/
 100          bdata u16 Pin_Mode;  //可位寻址变量
 101          
 102          sbit Pin10_Mode = Pin_Mode^0;
 103          sbit Pin11_Mode = Pin_Mode^1;
 104          
 105          sbit Pin12_Mode = Pin_Mode^2;
 106          sbit Pin13_Mode = Pin_Mode^3;
 107          sbit Pin14_Mode = Pin_Mode^4;
 108          sbit Pin15_Mode = Pin_Mode^5;
 109          sbit Pin16_Mode = Pin_Mode^6;
 110          sbit Pin17_Mode = Pin_Mode^7;
 111          
 112          sbit Pin20_Mode = Pin_Mode^8;
 113          sbit Pin21_Mode = Pin_Mode^9;
 114          sbit Pin22_Mode = Pin_Mode^10;
 115          sbit Pin23_Mode = Pin_Mode^11;
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 3   

 116          sbit Pin24_Mode = Pin_Mode^12;
 117          
 118          sbit Pin35_Mode = Pin_Mode^13;
 119          sbit Pin36_Mode = Pin_Mode^14;
 120          sbit Pin37_Mode = Pin_Mode^15;
 121          
 122          s8 xdata Pin10_Task_Number = 1; //  bit Pin10_Mode = 1;
 123          s8 xdata Pin11_Task_Number = 2; //  bit Pin11_Mode = 1;
 124          
 125          s8 xdata Pin12_Task_Number = 1; //  bit Pin12_Mode = 0;
 126          s8 xdata Pin13_Task_Number = 2; //  bit Pin13_Mode = 0;
 127          s8 xdata Pin14_Task_Number = 3; //  bit Pin14_Mode = 0;
 128          s8 xdata Pin15_Task_Number = 4; //  bit Pin15_Mode = 0;
 129          s8 xdata Pin16_Task_Number = 5; //  bit Pin16_Mode = 0;
 130          s8 xdata Pin17_Task_Number = 6; //  bit Pin17_Mode = 0;
 131          
 132          s8 xdata Pin20_Task_Number = 4; //  bit Pin20_Mode = 0;
 133          s8 xdata Pin21_Task_Number = 4; //  bit Pin21_Mode = 0;
 134          s8 xdata Pin22_Task_Number = 4; //  bit Pin22_Mode = 0;
 135          s8 xdata Pin23_Task_Number = 4; //  bit Pin23_Mode = 0;
 136          s8 xdata Pin24_Task_Number = 4; //  bit Pin24_Mode = 0;
 137          
 138          s8 xdata Pin35_Task_Number = 1; //  bit Pin35_Mode = 1;
 139          s8 xdata Pin36_Task_Number = 2; //  bit Pin36_Mode = 1;
 140          s8 xdata Pin37_Task_Number = 3; //  bit Pin37_Mode = 1;
 141          
 142          
 143          
 144          /*将要更新的任务号*/
 145          u8 Task_Number = 0;  //正常触发任务号（自锁触发）
 146          u8 Task_Number_Immediate = 0;  //立即触发任务号 （立即触发）
 147          
 148          /*任务运行控制位*/
 149          bit Task1 = 0;  //任务1 运行(1)/暂停(0)
 150          bit Task2 = 0;
 151          bit Task3 = 0;
 152          bit Task4 = 0;
 153          bit Task5 = 0;
 154          bit Task6 = 0;
 155          
 156          /*任务运行模式*/
 157          u8 xdata Task1_Mode = 1;  //任务1运行时的模式
 158          u8 xdata Task2_Mode = 1;
 159          u8 xdata Task3_Mode = 1;
 160          u8 xdata Task4_Mode = 1;
 161          u8 xdata Task5_Mode = 1;
 162          u8 xdata Task6_Mode = 1;
 163          
 164          /*任务输出位*/
 165          bit Task1_Output = 0;
 166          bit Task2_Output = 0;
 167          bit Task3_Output = 0;
 168          bit Task4_Output = 0;
 169          bit Task5_Output = 0;
 170          bit Task6_Output = 0;
 171          
 172          /*时间区间间歇模式*/
 173          
 174          //对所有任务
 175          bdata u8 Task_OverTime_Reset;  //设置可位寻址变量
 176          sbit Task1_OverTime_Reset = Task_OverTime_Reset^1;
 177          sbit Task2_OverTime_Reset = Task_OverTime_Reset^2;
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 4   

 178          sbit Task3_OverTime_Reset = Task_OverTime_Reset^3;
 179          sbit Task4_OverTime_Reset = Task_OverTime_Reset^4;
 180          sbit Task5_OverTime_Reset = Task_OverTime_Reset^5;
 181          sbit Task6_OverTime_Reset = Task_OverTime_Reset^6;
 182          
 183          /*任务一*/
 184          s16 xdata Task1_StartTime = 0;//任务1起始运行时间
 185          s16 xdata Task1_EndTime = 1439;//任务1结束运行时间
 186          s32 xdata Task1_OverTime = 2*3000; //任务1运行超时时间
 187          u32 xdata Task1_OverTime_Count=0; //任务1运行超时时间计数器
 188          //bit Task1_OverTime_Reset = 0; //任务1运行超时自动复位控制位
 189                                        //用于控制任务是否永久运行
 190                                        //1:自动复位 ，任务超时将复位超时计数，任务永久运行
 191                                        //0:不自动复位 任务超时将关闭
 192          
 193          bit Task1_OnState = 1; //表示Task1输出ON状态 1：有输出 0；无输出
 194          s32 xdata Task1_OnTime = 2*1;  //表示Task1输出ON状态的时间
 195          s32 xdata Task1_OffTime = 2*1; //表示Task1输出OFF状态的时间
 196          
 197          u32 xdata Task1_CountTime = 1;  //任务1 ON/OFF状态时间计数器
 198          
 199          /*任务二*/
 200          s16 xdata Task2_StartTime = 0;//任务2起始运行时间
 201          s16 xdata Task2_EndTime = 1439;//任务2结束运行时间
 202          s32 xdata Task2_OverTime = 2*3000; //任务2运行超时时间
 203          u32 xdata Task2_OverTime_Count=0; //任务2运行超时时间计数器
 204          //bit Task2_OverTime_Reset = 0; //任务2运行超时自动复位控制位
 205                                        //用于控制任务是否永久运行
 206                                        //1:自动复位 ，任务超时将复位超时计数，任务永久运行
 207                                        //0:不自动复位 任务超时将关闭
 208          
 209          bit Task2_OnState = 1; //表示Task2输出ON状态 1：有输出 0；无输出
 210          s32 xdata Task2_OnTime = 2*1;  //表示Task2输出ON状态的时间
 211          s32 xdata Task2_OffTime = 2*1; //表示Task2输出OFF状态的时间
 212          
 213          u32 xdata Task2_CountTime = 1;  //任务2 ON/OFF状态时间计数器
 214          
 215          /*任务三*/
 216          s16 xdata Task3_StartTime = 0;//任务3起始运行时间
 217          s16 xdata Task3_EndTime = 1439;//任务3结束运行时间
 218          s32 xdata Task3_OverTime = 2*3000; //任务3运行超时时间
 219          u32 xdata Task3_OverTime_Count=0; //任务3运行超时时间计数器
 220          //bit Task3_OverTime_Reset = 0; //任务3运行超时自动复位控制位
 221                                        //用于控制任务是否永久运行
 222                                        //1:自动复位 ，任务超时将复位超时计数，任务永久运行
 223                                        //0:不自动复位 任务超时将关闭
 224          
 225          bit Task3_OnState = 1; //表示Task3输出ON状态 1：有输出 0；无输出
 226          s32 xdata Task3_OnTime = 2*1;  //表示Task3输出ON状态的时间
 227          s32 xdata Task3_OffTime = 2*1; //表示Task3输出OFF状态的时间
 228          
 229          u32 xdata Task3_CountTime = 1;  //任务3 ON/OFF状态时间计数器
 230          
 231          /*任务四*/
 232          s16 xdata Task4_StartTime = 0;//任务4起始运行时间
 233          s16 xdata Task4_EndTime = 1439;//任务4结束运行时间
 234          s32 xdata Task4_OverTime = 2*3000; //任务4运行超时时间
 235          u32 xdata Task4_OverTime_Count=0; //任务4运行超时时间计数器
 236          //bit Task4_OverTime_Reset = 0; //任务4运行超时自动复位控制位
 237                                        //用于控制任务是否永久运行
 238                                        //1:自动复位 ，任务超时将复位超时计数，任务永久运行
 239                                        //0:不自动复位 任务超时将关闭
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 5   

 240          
 241          bit Task4_OnState = 1; //表示Task4输出ON状态 1：有输出 0；无输出
 242          s32 xdata Task4_OnTime = 2*1;  //表示Task4输出ON状态的时间
 243          s32 xdata Task4_OffTime = 2*1; //表示Task4输出OFF状态的时间
 244          
 245          u32 xdata Task4_CountTime = 1;  //任务4 ON/OFF状态时间计数器
 246          
 247          /*任务五*/
 248          s16 xdata Task5_StartTime = 0;//任务5起始运行时间
 249          s16 xdata Task5_EndTime = 1439;//任务5结束运行时间
 250          s32 xdata Task5_OverTime = 2*3000; //任务5运行超时时间
 251          u32 xdata Task5_OverTime_Count=0; //任务5运行超时时间计数器
 252          //bit Task5_OverTime_Reset = 0; //任务5运行超时自动复位控制位
 253                                        //用于控制任务是否永久运行
 254                                        //1:自动复位 ，任务超时将复位超时计数，任务永久运行
 255                                        //0:不自动复位 任务超时将关闭
 256          
 257          bit Task5_OnState = 1; //表示Task5输出ON状态 1：有输出 0；无输出
 258          s32 xdata Task5_OnTime = 2*1;  //表示Task5输出ON状态的时间
 259          s32 xdata Task5_OffTime = 2*1; //表示Task5输出OFF状态的时间
 260          
 261          u32 xdata Task5_CountTime = 1;  //任务5 ON/OFF状态时间计数器
 262          
 263          /*任务六*/
 264          s16 xdata Task6_StartTime = 0;//任务6起始运行时间
 265          s16 xdata Task6_EndTime = 1439;//任务6结束运行时间
 266          s32 xdata Task6_OverTime = 2*3000; //任务6运行超时时间
 267          u32 xdata Task6_OverTime_Count=0; //任务6运行超时时间计数器
 268          //bit Task6_OverTime_Reset = 0; //任务6运行超时自动复位控制位
 269                                        //用于控制任务是否永久运行
 270                                        //1:自动复位 ，任务超时将复位超时计数，任务永久运行
 271                                        //0:不自动复位 任务超时将关闭
 272          
 273          bit Task6_OnState = 1; //表示Task6输出ON状态 1：有输出 0；无输出
 274          s32 xdata Task6_OnTime = 2*1;  //表示Task6输出ON状态的时间
 275          s32 xdata Task6_OffTime = 2*1; //表示Task6输出OFF状态的时间
 276          
 277          u32 xdata Task6_CountTime = 1;  //任务6 ON/OFF状态时间计数器
 278          
 279          /******************************************************************************/
 280          // 函数名称：Task_Input_Update
 281          // 输入参数：无
 282          // 输出参数：无 
 283          // 函数功能：对端口进行扫描，用于触发继电器任务
 284          //     说明：首先记录下所有被触发的输入型端口，当该端口
 285          //           被释放，则更新该端口所匹配的任务，同时清除
 286          //           端口记录
 287          /******************************************************************************/
 288          void Task_Input_Update(void)
 289          {
 290   1        /*记录下所有被触发的端口*/
 291   1        /*如果端口模式是 1.输入模式
 292   1                  并且为 2.自锁模式
 293   1                         3.端口被触发
 294   1            则记录*/
 295   1        if((Pin12_Mode==0)&&(Pin12_Trigger_Mode==0)&&(P12==0)){Pin12=1;}
 296   1        if((Pin13_Mode==0)&&(Pin13_Trigger_Mode==0)&&(P13==0)){Pin13=1;}
 297   1        if((Pin14_Mode==0)&&(Pin14_Trigger_Mode==0)&&(P14==0)){Pin14=1;}
 298   1        if((Pin15_Mode==0)&&(Pin15_Trigger_Mode==0)&&(P15==0)){Pin15=1;}
 299   1        if((Pin16_Mode==0)&&(Pin16_Trigger_Mode==0)&&(P16==0)){Pin16=1;}
 300   1        if((Pin17_Mode==0)&&(Pin17_Trigger_Mode==0)&&(P17==0)){Pin17=1;}
 301   1        
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 6   

 302   1        if((Pin20_Mode==0)&&(Pin20_Trigger_Mode==0)&&(P20==0)){Pin20=1;}
 303   1        if((Pin21_Mode==0)&&(Pin21_Trigger_Mode==0)&&(P21==0)){Pin21=1;}
 304   1        if((Pin22_Mode==0)&&(Pin22_Trigger_Mode==0)&&(P22==0)){Pin22=1;}
 305   1        if((Pin23_Mode==0)&&(Pin23_Trigger_Mode==0)&&(P23==0)){Pin23=1;}
 306   1        if((Pin24_Mode==0)&&(Pin24_Trigger_Mode==0)&&(P24==0)){Pin24=1;}
 307   1        
 308   1        if((Pin35_Mode==0)&&(Pin35_Trigger_Mode==0)&&(P35==0)){Pin35=1;}
 309   1        if((Pin36_Mode==0)&&(Pin36_Trigger_Mode==0)&&(P36==0)){Pin36=1;}
 310   1        if((Pin37_Mode==0)&&(Pin37_Trigger_Mode==0)&&(P37==0)){Pin37=1;}
 311   1        
 312   1        
 313   1        /*自锁模式的更新*/
 314   1        /*每次只更新一个任务状态*/
 315   1        //对每一个记录的端口进行扫描执行任务号设置
 316   1        //假定现在有多个任务被记录
 317   1        //单个扫描周期只处理一个记录信号,并且此时端口被释放
 318   1        if((Pin12==1)&&(P12==1)){   
 319   2          /*更新任务号设置为Pin12触发任务号*/
 320   2          Task_Number = Pin12_Task_Number;  
 321   2          Pin12=0;   //复位端口触发状态
 322   2        }
 323   1        else if((Pin13==1)&&(P13==1)){   //松手检测
 324   2          Task_Number = Pin13_Task_Number;
 325   2          Pin13=0;   
 326   2        }
 327   1        else if((Pin14==1)&&(P14==1)){   //松手检测
 328   2          Task_Number = Pin14_Task_Number;
 329   2          Pin14=0;   
 330   2        }
 331   1        else if((Pin15==1)&&(P15==1)){   //松手检测
 332   2          Task_Number = Pin15_Task_Number;
 333   2          Pin15=0;   
 334   2        }
 335   1        else if((Pin16==1)&&(P16==1)){   //松手检测
 336   2          Task_Number = Pin16_Task_Number;
 337   2          Pin16=0;   
 338   2        }
 339   1        else if((Pin17==1)&&(P17==1)){  //松手检测
 340   2          Task_Number = Pin17_Task_Number;
 341   2          Pin17=0;   
 342   2        }
 343   1        else if((Pin20==1)&&(P20==1)){  //松手检测
 344   2          Task_Number = Pin20_Task_Number;
 345   2          Pin20=0;   
 346   2        }
 347   1        else if((Pin21==1)&&(P21==1)){   //松手检测
 348   2          Task_Number = Pin21_Task_Number;
 349   2          Pin21=0;   
 350   2        }
 351   1        else if((Pin22==1)&&(P22==1)){   //松手检测
 352   2          Task_Number = Pin22_Task_Number;
 353   2          Pin22=0;   
 354   2        }
 355   1        else if((Pin23==1)&&(P23==1)){   //松手检测
 356   2          Task_Number = Pin23_Task_Number;
 357   2          Pin23=0;   
 358   2        }
 359   1        else if((Pin24==1)&&(P24==1)){   //松手检测
 360   2          Task_Number = Pin24_Task_Number;
 361   2          Pin24=0;   
 362   2        }
 363   1        else if((Pin35==1)&&(P35==1)){   //松手检测
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 7   

 364   2          Task_Number = Pin35_Task_Number;
 365   2          Pin35=0;   
 366   2        }
 367   1        else if((Pin36==1)&&(P36==1)){   //松手检测
 368   2          Task_Number = Pin36_Task_Number;
 369   2          Pin36=0;   
 370   2        }
 371   1        else if((Pin37==1)&&(P37==1)){   //松手检测
 372   2          Task_Number = Pin37_Task_Number;
 373   2          Pin37=0;   
 374   2        }
 375   1        
 376   1          
 377   1        /*如果端口模式是 1.输入模式
 378   1                    并且 2.立即触发模式
 379   1                    并且 3.外部模拟按键状态为未按下
 380   1                    并且 4.端口处于触发状态
 381   1                  则更新任务号*/
 382   1        
 383   1        if((Pin12_Mode==0)&&(Pin12_Trigger_Mode==1)&&(Pin12_Key==0)&&(P12==0)){
 384   2          Task_Number_Immediate = Pin12_Task_Number; //立即更新任务号
 385   2          Pin12_Key = 1;   //外部虚拟按键状态变为按下   
 386   2        }
 387   1        else if((Pin13_Mode==0)&&(Pin13_Trigger_Mode==1)&&(Pin13_Key==0)&&(P13==0)){
 388   2          Task_Number_Immediate = Pin13_Task_Number;
 389   2          Pin13_Key = 1;   //外部虚拟按键状态变为按下
 390   2        }
 391   1        else if((Pin14_Mode==0)&&(Pin14_Trigger_Mode==1)&&(Pin14_Key==0)&&(P14==0)){
 392   2          Task_Number_Immediate = Pin14_Task_Number;
 393   2          Pin14_Key = 1;   //外部虚拟按键状态变为按下
 394   2        }
 395   1        else if((Pin15_Mode==0)&&(Pin15_Trigger_Mode==1)&&(Pin15_Key==0)&&(P15==0)){
 396   2          Task_Number_Immediate = Pin15_Task_Number;
 397   2          Pin15_Key = 1;   //外部虚拟按键状态变为按下
 398   2        }
 399   1        else if((Pin16_Mode==0)&&(Pin16_Trigger_Mode==1)&&(Pin16_Key==0)&&(P16==0)){
 400   2          Task_Number_Immediate = Pin16_Task_Number;
 401   2          Pin16_Key = 1;   //外部虚拟按键状态变为按下
 402   2        }
 403   1        else if((Pin17_Mode==0)&&(Pin17_Trigger_Mode==1)&&(Pin17_Key==0)&&(P17==0)){
 404   2          Task_Number_Immediate = Pin17_Task_Number;
 405   2          Pin17_Key = 1;   //外部虚拟按键状态变为按下
 406   2        }
 407   1        
 408   1        else if((Pin20_Mode==0)&&(Pin20_Trigger_Mode==1)&&(Pin20_Key==0)&&(P20==0)){
 409   2          Task_Number_Immediate = Pin20_Task_Number;
 410   2          Pin20_Key = 1;   //外部虚拟按键状态变为按下
 411   2        }
 412   1        else if((Pin21_Mode==0)&&(Pin21_Trigger_Mode==1)&&(Pin21_Key==0)&&(P21==0)){
 413   2          Task_Number_Immediate = Pin21_Task_Number;
 414   2          Pin21_Key = 1;   //外部虚拟按键状态变为按下
 415   2        }
 416   1        else if((Pin22_Mode==0)&&(Pin22_Trigger_Mode==1)&&(Pin22_Key==0)&&(P22==0)){
 417   2          Task_Number_Immediate = Pin22_Task_Number;
 418   2          Pin22_Key = 1;   //外部虚拟按键状态变为按下
 419   2        }
 420   1        else if((Pin23_Mode==0)&&(Pin23_Trigger_Mode==1)&&(Pin23_Key==0)&&(P23==0)){
 421   2          Task_Number_Immediate = Pin23_Task_Number;
 422   2          Pin23_Key = 1;   //外部虚拟按键状态变为按下
 423   2        }
 424   1        else if((Pin24_Mode==0)&&(Pin24_Trigger_Mode==1)&&(Pin24_Key==0)&&(P24==0)){
 425   2          Task_Number_Immediate = Pin24_Task_Number;
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 8   

 426   2          Pin24_Key = 1;   //外部虚拟按键状态变为按下
 427   2        }
 428   1        
 429   1        else if((Pin35_Mode==0)&&(Pin35_Trigger_Mode==1)&&(Pin35_Key==0)&&(P35==0)){
 430   2          Task_Number_Immediate = Pin35_Task_Number;
 431   2          Pin35_Key = 1;   //外部虚拟按键状态变为按下
 432   2        }
 433   1        else if((Pin36_Mode==0)&&(Pin36_Trigger_Mode==1)&&(Pin36_Key==0)&&(P36==0)){
 434   2          Task_Number_Immediate = Pin36_Task_Number;
 435   2          Pin36_Key = 1;   //外部虚拟按键状态变为按下
 436   2        }
 437   1        else if((Pin37_Mode==0)&&(Pin37_Trigger_Mode==1)&&(Pin37_Key==0)&&(P37==0)){
 438   2          Task_Number_Immediate = Pin37_Task_Number;
 439   2          Pin37_Key = 1;   //外部虚拟按键状态变为按下
 440   2        }
 441   1        
 442   1        
 443   1        //如果端口被释放，外部虚拟按键变为未按下，允许重新设置
 444   1        if((Pin12_Key==1)&&(P12==1)){Pin12_Key = 0;}
 445   1        if((Pin13_Key==1)&&(P13==1)){Pin13_Key = 0;}
 446   1        if((Pin14_Key==1)&&(P14==1)){Pin14_Key = 0;}
 447   1        if((Pin15_Key==1)&&(P15==1)){Pin15_Key = 0;}
 448   1        if((Pin16_Key==1)&&(P16==1)){Pin16_Key = 0;}
 449   1        if((Pin17_Key==1)&&(P17==1)){Pin17_Key = 0;} 
 450   1      
 451   1        if((Pin20_Key==1)&&(P20==1)){Pin20_Key = 0;}
 452   1        if((Pin21_Key==1)&&(P21==1)){Pin21_Key = 0;}
 453   1        if((Pin22_Key==1)&&(P22==1)){Pin22_Key = 0;}  
 454   1        if((Pin23_Key==1)&&(P23==1)){Pin23_Key = 0;}
 455   1        if((Pin24_Key==1)&&(P24==1)){Pin24_Key = 0;}
 456   1        
 457   1        if((Pin35_Key==1)&&(P35==1)){Pin35_Key = 0;}
 458   1        if((Pin36_Key==1)&&(P36==1)){Pin36_Key = 0;}
 459   1        if((Pin37_Key==1)&&(P37==1)){Pin37_Key = 0;}
 460   1        
 461   1        /*自锁模式更新新的触发任务*/
 462   1        switch(Task_Number)
 463   1        {
 464   2          case 1:   //任务1
 465   2            Task1=~Task1;  //开启或关闭任务1
 466   2            Task_Number = 0; //复位要更新的任务号
 467   2            break;
 468   2          case 2:   //任务2
 469   2            Task2=~Task2;  //开启或关闭任务2
 470   2            Task_Number = 0;
 471   2            break;
 472   2          case 3:   //任务3
 473   2            Task3=~Task3;  //开启或关闭任务3
 474   2            Task_Number = 0;
 475   2            break;
 476   2          case 4:   //任务4
 477   2            Task4=~Task4;  //开启或关闭任务4
 478   2            Task_Number = 0;
 479   2            break;
 480   2          case 5:   //任务5
 481   2            Task5=~Task5;  //开启或关闭任务5
 482   2            Task_Number = 0;
 483   2            break;
 484   2          case 6:   //任务6
 485   2            Task6=~Task6;  //开启或关闭任务6
 486   2            Task_Number = 0;
 487   2            break;
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 9   

 488   2        }
 489   1        
 490   1        /*立即模式控制任务状态*/
 491   1        switch(Task_Number_Immediate)
 492   1        {
 493   2          case 1:   //任务1
 494   2            Task1=1;  //开启任务1
 495   2            Task_Number_Immediate = 0; //复位要更新的任务号
 496   2            break;
 497   2          case 2:   //任务2
 498   2            Task2=1;  //开启任务2
 499   2            Task_Number_Immediate = 0;
 500   2            break;
 501   2          case 3:   //任务3
 502   2            Task3=1;  //开启任务3
 503   2            Task_Number_Immediate = 0;
 504   2            break;
 505   2          case 4:   //任务4
 506   2            Task4=1;  //开启任务4
 507   2            Task_Number_Immediate = 0;
 508   2            break;
 509   2          case 5:   //任务5
 510   2            Task5=1;  //开启任务5
 511   2            Task_Number_Immediate = 0;
 512   2            break;
 513   2          case 6:   //任务6
 514   2            Task6=1;  //开启任务6
 515   2            Task_Number_Immediate = 0;
 516   2            break;
 517   2        
 518   2        }
 519   1      }
 520          /******************************************************************************/
 521          // 函数名称：(Task1~Task6)_Update
 522          // 输入参数：无
 523          // 输出参数：无 
 524          // 函数功能：执行任务函数
 525          /******************************************************************************/
 526          
 527          void Task1_Output_Update(void)
 528          {
 529   1          if(Task1 == 1)
 530   1          {
 531   2            switch(Task1_Mode)
 532   2            {
 533   3              case 1:
 534   3                if((Task1_StartTime<=NowTime)&&(NowTime<=Task1_EndTime)
 535   3                  &&(Task1_OverTime_Count<Task1_OverTime)){ 
 536   4                    Task1_OverTime_Count++;
 537   4                  
 538   4                    if(Task1_OnState==1) //首先如果处于On状态
 539   4                      {
 540   5                        
 541   5                      if(Task1_CountTime<Task1_OnTime){
 542   6                        Task1_CountTime++;
 543   6                        Task1_Output = 1;
 544   6                      }else{
 545   6                        Task1_CountTime = 1;  //复位时间计数器
 546   6                        Task1_OnState = 0; //切换到OFF状态
 547   6                      }
 548   5                      
 549   5                    }else{  //否则处于Off状态
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 10  

 550   5                      
 551   5                      if(Task1_CountTime<Task1_OffTime){
 552   6                        Task1_CountTime++;
 553   6                        Task1_Output = 0;
 554   6                      }else{
 555   6                        Task1_CountTime = 1;  //复位时间计数器
 556   6                        Task1_OnState = 1; //切换到ON状态
 557   6                      }
 558   5                    } 
 559   4                    
 560   4                }else{  //不满足时间运行条件则不输出
 561   4                      
 562   4                        //在时间区间但是任务超时 
 563   4                        //不在时间区间，任务还未超时
 564   4                        //不在时间区间，任务已经超时
 565   4                  
 566   4                  //如果任务一不在时间区间但还没有超时
 567   4                  //重新回到时间区间将重新开始
 568   4                  //默认输出ON
 569   4                  if(Task1_OverTime_Count<Task1_OverTime){
 570   5                    
 571   5                    Task1_Output = 0;   //禁止任务1输出
 572   5                    Task1_OverTime_Count=0;  //复位超时计数器
 573   5                    Task1_CountTime = 1;  //复位时间计数器
 574   5                    Task1_OnState = 1; //切换到ON状态
 575   5                    
 576   5                    //否则如果任务一已经超时
 577   5                  }else if(Task1_OverTime_Count==Task1_OverTime){
 578   5                    
 579   5                    //使能超时任务自动复位,为了持续运行
 580   5                    if(Task1_OverTime_Reset){
 581   6                      
 582   6                      Task1_OverTime_Count=0;  //复位超时计数器
 583   6                                               //如果还在时间区间内将继续运行
 584   6                                               //如果不在时间区间内将等待继续运行
 585   6                    }else{  
 586   6                      
 587   6                      Task1=0; //关闭Task
 588   6                      Task1_OverTime_Count=0;  //复位超时计数器
 589   6                      Task1_CountTime = 1;  //复位时间计数器
 590   6                      Task1_OnState = 1; //切换到ON状态
 591   6                      Task1_Output = 0;   //禁止任务1输出
 592   6                      
 593   6                    }
 594   5                    
 595   5                  }
 596   4                  
 597   4                }
 598   3                break;
 599   3            }
 600   2          }else{  //任务如果不运行则不输出
 601   2            Task1_OverTime_Count=0;  //复位超时计数器
 602   2            Task1_CountTime = 1;  //复位时间计数器
 603   2            Task1_OnState = 1; //切换到ON状态
 604   2            Task1_Output = 0;   //禁止任务1输出
 605   2            
 606   2          }
 607   1          
 608   1      /******************************************************************************/
 609   1      // 任务一输出处理部分（以此注释向下）
 610   1      /******************************************************************************/
 611   1        if(Task1_Output==1){
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 11  

 612   2          
 613   2          if((Pin10_Mode==1)&&(Pin10_Task_Number==1)){P10=0;}
 614   2          if((Pin11_Mode==1)&&(Pin11_Task_Number==1)){P11=0;}
 615   2          if((Pin12_Mode==1)&&(Pin12_Task_Number==1)){P12=0;}
 616   2          if((Pin13_Mode==1)&&(Pin13_Task_Number==1)){P13=0;}
 617   2          if((Pin14_Mode==1)&&(Pin14_Task_Number==1)){P14=0;}
 618   2          if((Pin15_Mode==1)&&(Pin15_Task_Number==1)){P15=0;}
 619   2          if((Pin16_Mode==1)&&(Pin16_Task_Number==1)){P16=0;}
 620   2          if((Pin17_Mode==1)&&(Pin17_Task_Number==1)){P17=0;}
 621   2          
 622   2          if((Pin20_Mode==1)&&(Pin20_Task_Number==1)){P20=0;}
 623   2          if((Pin21_Mode==1)&&(Pin21_Task_Number==1)){P21=0;}
 624   2          if((Pin22_Mode==1)&&(Pin22_Task_Number==1)){P22=0;}
 625   2          if((Pin23_Mode==1)&&(Pin23_Task_Number==1)){P23=0;}
 626   2          if((Pin24_Mode==1)&&(Pin24_Task_Number==1)){P24=0;}
 627   2          
 628   2          if((Pin35_Mode==1)&&(Pin35_Task_Number==1)){P35=0;}
 629   2          if((Pin36_Mode==1)&&(Pin36_Task_Number==1)){P36=0;}
 630   2          if((Pin37_Mode==1)&&(Pin37_Task_Number==1)){P37=0;}
 631   2          
 632   2        }else{
 633   2          
 634   2          if((Pin10_Mode==1)&&(Pin10_Task_Number==1)){P10=1;}
 635   2          if((Pin11_Mode==1)&&(Pin11_Task_Number==1)){P11=1;}
 636   2          if((Pin12_Mode==1)&&(Pin12_Task_Number==1)){P12=1;}
 637   2          if((Pin13_Mode==1)&&(Pin13_Task_Number==1)){P13=1;}
 638   2          if((Pin14_Mode==1)&&(Pin14_Task_Number==1)){P14=1;}
 639   2          if((Pin15_Mode==1)&&(Pin15_Task_Number==1)){P15=1;}
 640   2          if((Pin16_Mode==1)&&(Pin16_Task_Number==1)){P16=1;}
 641   2          if((Pin17_Mode==1)&&(Pin17_Task_Number==1)){P17=1;}
 642   2          
 643   2          if((Pin20_Mode==1)&&(Pin20_Task_Number==1)){P20=1;}
 644   2          if((Pin21_Mode==1)&&(Pin21_Task_Number==1)){P21=1;}
 645   2          if((Pin22_Mode==1)&&(Pin22_Task_Number==1)){P22=1;}
 646   2          if((Pin23_Mode==1)&&(Pin23_Task_Number==1)){P23=1;}
 647   2          if((Pin24_Mode==1)&&(Pin24_Task_Number==1)){P24=1;}
 648   2          
 649   2          if((Pin35_Mode==1)&&(Pin35_Task_Number==1)){P35=1;}
 650   2          if((Pin36_Mode==1)&&(Pin36_Task_Number==1)){P36=1;}
 651   2          if((Pin37_Mode==1)&&(Pin37_Task_Number==1)){P37=1;}
 652   2        }
 653   1      }
 654          
 655          void Task2_Output_Update(void)
 656          {
 657   1          if(Task2 == 1)
 658   1          {
 659   2            switch(Task2_Mode)
 660   2            {
 661   3              case 1:
 662   3                if((Task2_StartTime<=NowTime)&&(NowTime<=Task2_EndTime)
 663   3                  &&(Task2_OverTime_Count<Task2_OverTime)){
 664   4                    Task2_OverTime_Count++;
 665   4                  
 666   4                    if(Task2_OnState==1) //首先如果处于On状态
 667   4                      {
 668   5                        
 669   5                      if(Task2_CountTime<Task2_OnTime){
 670   6                        Task2_CountTime++;
 671   6                        Task2_Output = 1;
 672   6                      }else{
 673   6                        Task2_CountTime = 1;  //复位时间计数器
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 12  

 674   6                        Task2_OnState = 0; //切换到OFF状态
 675   6                      }
 676   5                      
 677   5                    }else{  //否则处于Off状态
 678   5                      
 679   5                      if(Task2_CountTime<Task2_OffTime){
 680   6                        Task2_CountTime++;
 681   6                        Task2_Output = 0;
 682   6                      }else{
 683   6                        Task2_CountTime = 1;  //复位时间计数器
 684   6                        Task2_OnState = 1; //切换到ON状态
 685   6                      }
 686   5                    } 
 687   4                    
 688   4               }else{  //不满足时间运行条件则不输出
 689   4      
 690   4                        //在时间区间但是任务超时 
 691   4                        //不在时间区间，任务还未超时
 692   4                        //不在时间区间，任务已经超时           
 693   4                 
 694   4                 //如果任务二不在时间区间但还没有超时
 695   4                  if(Task2_OverTime_Count<Task2_OverTime){
 696   5                    
 697   5                    Task2_OverTime_Count=0;  //复位超时计数器
 698   5                    Task2_CountTime = 1;  //复位时间计数器
 699   5                    Task2_Output = 0;   //禁止任务2输出
 700   5                    Task2_OnState = 1; //切换到ON状态
 701   5                    
 702   5                    //否则如果任务一已经超时
 703   5                  }else if(Task2_OverTime_Count==Task2_OverTime){
 704   5                    
 705   5                    //使能超时任务自动复位
 706   5                    if(Task2_OverTime_Reset){
 707   6                      
 708   6                      Task2_OverTime_Count=0;  //复位超时计数器
 709   6                                               //如果还在时间区间内将继续运行
 710   6                                               //如果不在时间区间内将等待继续运行
 711   6                    }else{  
 712   6                      
 713   6                      Task2=0; //关闭Task
 714   6                      Task2_OverTime_Count=0;  //复位超时计数器
 715   6                      Task2_CountTime = 1;  //复位时间计数器
 716   6                      Task2_Output = 0;   //禁止任务2输出
 717   6                      Task2_OnState = 1; //切换到ON状态
 718   6                    }
 719   5                    
 720   5                  }
 721   4               }
 722   3               break;
 723   3            }
 724   2          }else{
 725   2            Task2_OverTime_Count=0;  //复位超时计数器
 726   2            Task2_CountTime = 1;  //复位时间计数器
 727   2            Task2_Output = 0;   //禁止任务2输出
 728   2            Task2_OnState = 1; //切换到ON状态
 729   2          }
 730   1          
 731   1      /******************************************************************************/
 732   1      // 任务二输出处理部分（以此注释向下）
 733   1      /******************************************************************************/
 734   1        if(Task2_Output==1){
 735   2          if((Pin10_Mode==1)&&(Pin10_Task_Number==2)){P10=0;}
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 13  

 736   2          if((Pin11_Mode==1)&&(Pin11_Task_Number==2)){P11=0;}
 737   2          if((Pin12_Mode==1)&&(Pin12_Task_Number==2)){P12=0;}
 738   2          if((Pin13_Mode==1)&&(Pin13_Task_Number==2)){P13=0;}
 739   2          if((Pin14_Mode==1)&&(Pin14_Task_Number==2)){P14=0;}
 740   2          if((Pin15_Mode==1)&&(Pin15_Task_Number==2)){P15=0;}
 741   2          if((Pin16_Mode==1)&&(Pin16_Task_Number==2)){P16=0;}
 742   2          if((Pin17_Mode==1)&&(Pin17_Task_Number==2)){P17=0;}
 743   2          
 744   2          if((Pin20_Mode==1)&&(Pin20_Task_Number==2)){P20=0;}
 745   2          if((Pin21_Mode==1)&&(Pin21_Task_Number==2)){P21=0;}
 746   2          if((Pin22_Mode==1)&&(Pin22_Task_Number==2)){P22=0;}
 747   2          if((Pin23_Mode==1)&&(Pin23_Task_Number==2)){P23=0;}
 748   2          if((Pin24_Mode==1)&&(Pin24_Task_Number==2)){P24=0;}
 749   2          
 750   2          if((Pin35_Mode==1)&&(Pin35_Task_Number==2)){P35=0;}
 751   2          if((Pin36_Mode==1)&&(Pin36_Task_Number==2)){P36=0;}
 752   2          if((Pin37_Mode==1)&&(Pin37_Task_Number==2)){P37=0;}
 753   2          
 754   2        }else{
 755   2          
 756   2          if((Pin10_Mode==1)&&(Pin10_Task_Number==2)){P10=1;}
 757   2          if((Pin11_Mode==1)&&(Pin11_Task_Number==2)){P11=1;}
 758   2          if((Pin12_Mode==1)&&(Pin12_Task_Number==2)){P12=1;}
 759   2          if((Pin13_Mode==1)&&(Pin13_Task_Number==2)){P13=1;}
 760   2          if((Pin14_Mode==1)&&(Pin14_Task_Number==2)){P14=1;}
 761   2          if((Pin15_Mode==1)&&(Pin15_Task_Number==2)){P15=1;}
 762   2          if((Pin16_Mode==1)&&(Pin16_Task_Number==2)){P16=1;}
 763   2          if((Pin17_Mode==1)&&(Pin17_Task_Number==2)){P17=1;}
 764   2          
 765   2          if((Pin20_Mode==1)&&(Pin20_Task_Number==2)){P20=1;}
 766   2          if((Pin21_Mode==1)&&(Pin21_Task_Number==2)){P21=1;}
 767   2          if((Pin22_Mode==1)&&(Pin22_Task_Number==2)){P22=1;}
 768   2          if((Pin23_Mode==1)&&(Pin23_Task_Number==2)){P23=1;}
 769   2          if((Pin24_Mode==1)&&(Pin24_Task_Number==2)){P24=1;}
 770   2          
 771   2          if((Pin35_Mode==1)&&(Pin35_Task_Number==2)){P35=1;}
 772   2          if((Pin36_Mode==1)&&(Pin36_Task_Number==2)){P36=1;}
 773   2          if((Pin37_Mode==1)&&(Pin37_Task_Number==2)){P37=1;}
 774   2        }   
 775   1      }
 776          
 777          
 778          void Task3_Output_Update(void)
 779          {
 780   1          if(Task3 == 1)
 781   1          {
 782   2            switch(Task3_Mode)
 783   2            {
 784   3              case 1:
 785   3                if((Task3_StartTime<=NowTime)&&(NowTime<=Task3_EndTime)
 786   3                  &&(Task3_OverTime_Count<Task3_OverTime)){ 
 787   4                    Task3_OverTime_Count++;
 788   4                  
 789   4                    if(Task3_OnState==1) //首先如果处于On状态
 790   4                      {
 791   5                        
 792   5                      if(Task3_CountTime<Task3_OnTime){
 793   6                        Task3_CountTime++;
 794   6                        Task3_Output = 1;
 795   6                      }else{
 796   6                        Task3_CountTime = 1;  //复位时间计数器
 797   6                        Task3_OnState = 0; //切换到OFF状态
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 14  

 798   6                      }
 799   5                      
 800   5                    }else{  //否则处于Off状态
 801   5                      
 802   5                      if(Task3_CountTime<Task3_OffTime){
 803   6                        Task3_CountTime++;
 804   6                        Task3_Output = 0;
 805   6                      }else{
 806   6                        Task3_CountTime = 1;  //复位时间计数器
 807   6                        Task3_OnState = 1; //切换到ON状态
 808   6                      }
 809   5                    } 
 810   4                    
 811   4                }else{  //不满足时间运行条件则不输出
 812   4                      
 813   4                        //在时间区间但是任务超时 
 814   4                        //不在时间区间，任务还未超时
 815   4                        //不在时间区间，任务已经超时
 816   4                  
 817   4                  //如果任务三不在时间区间但还没有超时
 818   4                  if(Task3_OverTime_Count<Task3_OverTime){
 819   5                    
 820   5                    Task3_OverTime_Count=0;  //复位超时计数器
 821   5                    Task3_CountTime = 1;  //复位时间计数器
 822   5                    Task3_Output = 0;   //禁止任务3输出
 823   5                    Task3_OnState = 1; //切换到ON状态
 824   5                    
 825   5                    //否则如果任务三已经超时
 826   5                  }else if(Task3_OverTime_Count==Task3_OverTime){
 827   5                    
 828   5                    //使能超时任务自动复位
 829   5                    if(Task3_OverTime_Reset){
 830   6                      
 831   6                      Task3_OverTime_Count=0;  //复位超时计数器
 832   6                                               //如果还在时间区间内将继续运行
 833   6                                               //如果不在时间区间内将等待继续运行
 834   6                    }else{  
 835   6                      
 836   6                      Task3=0; //关闭Task
 837   6                      Task3_OverTime_Count=0;  //复位超时计数器
 838   6                      Task3_CountTime = 1;  //复位时间计数器
 839   6                      Task3_Output = 0;   //禁止任务3输出
 840   6                      Task3_OnState = 1; //切换到ON状态
 841   6                    }
 842   5                    
 843   5                  }  
 844   4                }
 845   3                break;
 846   3            }
 847   2          }else{  //任务如果不运行则不输出
 848   2            Task3_OverTime_Count=0;  //复位超时计数器
 849   2            Task3_CountTime = 1;  //复位时间计数器
 850   2            Task3_Output = 0;   //禁止任务3输出
 851   2            Task3_OnState = 1; //切换到ON状态
 852   2          }
 853   1          
 854   1      /******************************************************************************/
 855   1      // 任务三输出处理部分（以此注释向下）
 856   1      /******************************************************************************/
 857   1        if(Task3_Output==1){
 858   2          if((Pin10_Mode==1)&&(Pin10_Task_Number==3)){P10=0;}
 859   2          if((Pin11_Mode==1)&&(Pin11_Task_Number==3)){P11=0;}
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 15  

 860   2          if((Pin12_Mode==1)&&(Pin12_Task_Number==3)){P12=0;}
 861   2          if((Pin13_Mode==1)&&(Pin13_Task_Number==3)){P13=0;}
 862   2          if((Pin14_Mode==1)&&(Pin14_Task_Number==3)){P14=0;}
 863   2          if((Pin15_Mode==1)&&(Pin15_Task_Number==3)){P15=0;}
 864   2          if((Pin16_Mode==1)&&(Pin16_Task_Number==3)){P16=0;}
 865   2          if((Pin17_Mode==1)&&(Pin17_Task_Number==3)){P17=0;}
 866   2          
 867   2          if((Pin20_Mode==1)&&(Pin20_Task_Number==3)){P20=0;}
 868   2          if((Pin21_Mode==1)&&(Pin21_Task_Number==3)){P21=0;}
 869   2          if((Pin22_Mode==1)&&(Pin22_Task_Number==3)){P22=0;}
 870   2          if((Pin23_Mode==1)&&(Pin23_Task_Number==3)){P23=0;}
 871   2          if((Pin24_Mode==1)&&(Pin24_Task_Number==3)){P24=0;}
 872   2          
 873   2          if((Pin35_Mode==1)&&(Pin35_Task_Number==3)){P35=0;}
 874   2          if((Pin36_Mode==1)&&(Pin36_Task_Number==3)){P36=0;}
 875   2          if((Pin37_Mode==1)&&(Pin37_Task_Number==3)){P37=0;}
 876   2          
 877   2        }else{
 878   2          
 879   2          if((Pin10_Mode==1)&&(Pin10_Task_Number==3)){P10=1;}
 880   2          if((Pin11_Mode==1)&&(Pin11_Task_Number==3)){P11=1;}
 881   2          if((Pin12_Mode==1)&&(Pin12_Task_Number==3)){P12=1;}
 882   2          if((Pin13_Mode==1)&&(Pin13_Task_Number==3)){P13=1;}
 883   2          if((Pin14_Mode==1)&&(Pin14_Task_Number==3)){P14=1;}
 884   2          if((Pin15_Mode==1)&&(Pin15_Task_Number==3)){P15=1;}
 885   2          if((Pin16_Mode==1)&&(Pin16_Task_Number==3)){P16=1;}
 886   2          if((Pin17_Mode==1)&&(Pin17_Task_Number==3)){P17=1;}
 887   2          
 888   2          if((Pin20_Mode==1)&&(Pin20_Task_Number==3)){P20=1;}
 889   2          if((Pin21_Mode==1)&&(Pin21_Task_Number==3)){P21=1;}
 890   2          if((Pin22_Mode==1)&&(Pin22_Task_Number==3)){P22=1;}
 891   2          if((Pin23_Mode==1)&&(Pin23_Task_Number==3)){P23=1;}
 892   2          if((Pin24_Mode==1)&&(Pin24_Task_Number==3)){P24=1;}
 893   2          
 894   2          if((Pin35_Mode==1)&&(Pin35_Task_Number==3)){P35=1;}
 895   2          if((Pin36_Mode==1)&&(Pin36_Task_Number==3)){P36=1;}
 896   2          if((Pin37_Mode==1)&&(Pin37_Task_Number==3)){P37=1;}
 897   2        } 
 898   1      }
 899          
 900          void Task4_Output_Update(void)
 901          {
 902   1          if(Task4 == 1)
 903   1          {
 904   2            switch(Task4_Mode)
 905   2            {
 906   3              case 1:
 907   3                if((Task4_StartTime<=NowTime)&&(NowTime<=Task4_EndTime)
 908   3                  &&(Task4_OverTime_Count<Task4_OverTime)){ 
 909   4                    Task4_OverTime_Count++;
 910   4                  
 911   4                    if(Task4_OnState==1) //首先如果处于On状态
 912   4                      {
 913   5                        
 914   5                      if(Task4_CountTime<Task4_OnTime){
 915   6                        Task4_CountTime++;
 916   6                        Task4_Output = 1;
 917   6                      }else{
 918   6                        Task4_CountTime = 1;  //复位时间计数器
 919   6                        Task4_OnState = 0; //切换到OFF状态
 920   6                      }
 921   5                      
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 16  

 922   5                    }else{  //否则处于Off状态
 923   5                      
 924   5                      if(Task4_CountTime<Task4_OffTime){
 925   6                        Task4_CountTime++;
 926   6                        Task4_Output = 0;
 927   6                      }else{
 928   6                        Task4_CountTime = 1;  //复位时间计数器
 929   6                        Task4_OnState = 1; //切换到ON状态
 930   6                      }
 931   5                    } 
 932   4                    
 933   4                }else{  //不满足时间运行条件则不输出
 934   4                      
 935   4                        //在时间区间但是任务超时 
 936   4                        //不在时间区间，任务还未超时
 937   4                        //不在时间区间，任务已经超时
 938   4                  
 939   4                  //如果任务四不在时间区间但还没有超时
 940   4                  if(Task4_OverTime_Count<Task4_OverTime){
 941   5                    
 942   5                    Task4_OverTime_Count=0;  //复位超时计数器
 943   5                    Task4_CountTime = 1;  //复位时间计数器
 944   5                    Task4_Output = 0;   //禁止任务4输出
 945   5                    Task4_OnState = 1; //切换到ON状态
 946   5                    
 947   5                    //否则如果任务四已经超时
 948   5                  }else if(Task4_OverTime_Count==Task4_OverTime){
 949   5                    
 950   5                    //使能超时任务自动复位
 951   5                    if(Task4_OverTime_Reset){
 952   6                      
 953   6                      Task4_OverTime_Count=0;  //复位超时计数器
 954   6                                               //如果还在时间区间内将继续运行
 955   6                                               //如果不在时间区间内将等待继续运行
 956   6                    }else{  
 957   6                      
 958   6                      Task4=0; //关闭Task
 959   6                      Task4_OverTime_Count=0;  //复位超时计数器
 960   6                      Task4_CountTime = 1;  //复位时间计数器
 961   6                      Task4_Output = 0;   //禁止任务4输出
 962   6                      Task4_OnState = 1; //切换到ON状态
 963   6                    }
 964   5                    
 965   5                  }
 966   4        
 967   4                }
 968   3                break;
 969   3            }
 970   2          }else{  //任务如果不运行则不输出
 971   2            Task4_OverTime_Count=0;  //复位超时计数器
 972   2            Task4_CountTime = 1;  //复位时间计数器
 973   2            Task4_Output = 0;   //禁止任务4输出
 974   2            Task4_OnState = 1; //切换到ON状态
 975   2          }
 976   1          
 977   1      /******************************************************************************/
 978   1      // 任务四输出处理部分（以此注释向下）
 979   1      /******************************************************************************/
 980   1        if(Task4_Output==1){
 981   2          if((Pin10_Mode==1)&&(Pin10_Task_Number==4)){P10=0;}
 982   2          if((Pin11_Mode==1)&&(Pin11_Task_Number==4)){P11=0;}
 983   2          if((Pin12_Mode==1)&&(Pin12_Task_Number==4)){P12=0;}
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 17  

 984   2          if((Pin13_Mode==1)&&(Pin13_Task_Number==4)){P13=0;}
 985   2          if((Pin14_Mode==1)&&(Pin14_Task_Number==4)){P14=0;}
 986   2          if((Pin15_Mode==1)&&(Pin15_Task_Number==4)){P15=0;}
 987   2          if((Pin16_Mode==1)&&(Pin16_Task_Number==4)){P16=0;}
 988   2          if((Pin17_Mode==1)&&(Pin17_Task_Number==4)){P17=0;}
 989   2          
 990   2          if((Pin20_Mode==1)&&(Pin20_Task_Number==4)){P20=0;}
 991   2          if((Pin21_Mode==1)&&(Pin21_Task_Number==4)){P21=0;}
 992   2          if((Pin22_Mode==1)&&(Pin22_Task_Number==4)){P22=0;}
 993   2          if((Pin23_Mode==1)&&(Pin23_Task_Number==4)){P23=0;}
 994   2          if((Pin24_Mode==1)&&(Pin24_Task_Number==4)){P24=0;}
 995   2          
 996   2          if((Pin35_Mode==1)&&(Pin35_Task_Number==4)){P35=0;}
 997   2          if((Pin36_Mode==1)&&(Pin36_Task_Number==4)){P36=0;}
 998   2          if((Pin37_Mode==1)&&(Pin37_Task_Number==4)){P37=0;}
 999   2          
1000   2        }else{
1001   2          
1002   2          if((Pin10_Mode==1)&&(Pin10_Task_Number==4)){P10=1;}
1003   2          if((Pin11_Mode==1)&&(Pin11_Task_Number==4)){P11=1;}
1004   2          if((Pin12_Mode==1)&&(Pin12_Task_Number==4)){P12=1;}
1005   2          if((Pin13_Mode==1)&&(Pin13_Task_Number==4)){P13=1;}
1006   2          if((Pin14_Mode==1)&&(Pin14_Task_Number==4)){P14=1;}
1007   2          if((Pin15_Mode==1)&&(Pin15_Task_Number==4)){P15=1;}
1008   2          if((Pin16_Mode==1)&&(Pin16_Task_Number==4)){P16=1;}
1009   2          if((Pin17_Mode==1)&&(Pin17_Task_Number==4)){P17=1;}
1010   2          
1011   2          if((Pin20_Mode==1)&&(Pin20_Task_Number==4)){P20=1;}
1012   2          if((Pin21_Mode==1)&&(Pin21_Task_Number==4)){P21=1;}
1013   2          if((Pin22_Mode==1)&&(Pin22_Task_Number==4)){P22=1;}
1014   2          if((Pin23_Mode==1)&&(Pin23_Task_Number==4)){P23=1;}
1015   2          if((Pin24_Mode==1)&&(Pin24_Task_Number==4)){P24=1;}
1016   2          
1017   2          if((Pin35_Mode==1)&&(Pin35_Task_Number==4)){P35=1;}
1018   2          if((Pin36_Mode==1)&&(Pin36_Task_Number==4)){P36=1;}
1019   2          if((Pin37_Mode==1)&&(Pin37_Task_Number==4)){P37=1;}
1020   2        } 
1021   1      }
1022          
1023          
1024          void Task5_Output_Update(void)
1025          {
1026   1          if(Task5 == 1)
1027   1          {
1028   2            switch(Task5_Mode)
1029   2            {
1030   3              case 1:
1031   3                if((Task5_StartTime<=NowTime)&&(NowTime<=Task5_EndTime)
1032   3                  &&(Task5_OverTime_Count<Task5_OverTime)){
1033   4                    Task5_OverTime_Count++;
1034   4                  
1035   4                    if(Task5_OnState==1) //首先如果处于On状态
1036   4                      {
1037   5                        
1038   5                      if(Task5_CountTime<Task5_OnTime){
1039   6                        Task5_CountTime++;
1040   6                        Task5_Output = 1;
1041   6                      }else{
1042   6                        Task5_CountTime = 1;  //复位时间计数器
1043   6                        Task5_OnState = 0; //切换到OFF状态
1044   6                      }
1045   5                      
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 18  

1046   5                    }else{  //否则处于Off状态
1047   5                      
1048   5                      if(Task5_CountTime<Task5_OffTime){
1049   6                        Task5_CountTime++;
1050   6                        Task5_Output = 0;
1051   6                      }else{
1052   6                        Task5_CountTime = 1;  //复位时间计数器
1053   6                        Task5_OnState = 1; //切换到ON状态
1054   6                      }
1055   5                    } 
1056   4                    
1057   4               }else{   //不满足时间运行条件则不输出
1058   4                      
1059   4                        //在时间区间但是任务超时 
1060   4                        //不在时间区间，任务还未超时
1061   4                        //不在时间区间，任务已经超时
1062   4                 
1063   4                 //如果任务五不在时间区间但还没有超时
1064   4                  if(Task5_OverTime_Count<Task5_OverTime){
1065   5                    
1066   5                    Task5_OverTime_Count=0;  //复位超时计数器
1067   5                    Task5_CountTime = 1;  //复位时间计数器
1068   5                    Task5_Output = 0;   //禁止任务5输出
1069   5                    Task5_OnState = 1; //切换到ON状态
1070   5                    
1071   5                    //否则如果任务五已经超时
1072   5                  }else if(Task5_OverTime_Count==Task5_OverTime){
1073   5                    
1074   5                    //使能超时任务自动复位
1075   5                    if(Task5_OverTime_Reset){
1076   6                      
1077   6                      Task5_OverTime_Count=0;  //复位超时计数器
1078   6                                               //如果还在时间区间内将继续运行
1079   6                                               //如果不在时间区间内将等待继续运行
1080   6                    }else{  
1081   6                      
1082   6                      Task5=0; //关闭Task
1083   6                      Task5_OverTime_Count=0;  //复位超时计数器
1084   6                      Task5_CountTime = 1;  //复位时间计数器
1085   6                      Task5_Output = 0;   //禁止任务5输出
1086   6                      Task5_OnState = 1; //切换到ON状态
1087   6                    }
1088   5                    
1089   5                  }
1090   4               }
1091   3               break;
1092   3            }
1093   2          }else{   //任务如果不运行则不输出
1094   2            Task5_OverTime_Count=0;  //复位超时计数器
1095   2            Task5_CountTime = 1;  //复位时间计数器
1096   2            Task5_Output = 0;   //禁止任务5输出
1097   2            Task5_OnState = 1; //切换到ON状态
1098   2          }
1099   1          
1100   1      /******************************************************************************/
1101   1      // 任务五输出处理部分（以此注释向下）
1102   1      /******************************************************************************/
1103   1        if(Task5_Output==1){
1104   2          if((Pin10_Mode==1)&&(Pin10_Task_Number==5)){P10=0;}
1105   2          if((Pin11_Mode==1)&&(Pin11_Task_Number==5)){P11=0;}
1106   2          if((Pin12_Mode==1)&&(Pin12_Task_Number==5)){P12=0;}
1107   2          if((Pin13_Mode==1)&&(Pin13_Task_Number==5)){P13=0;}
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 19  

1108   2          if((Pin14_Mode==1)&&(Pin14_Task_Number==5)){P14=0;}
1109   2          if((Pin15_Mode==1)&&(Pin15_Task_Number==5)){P15=0;}
1110   2          if((Pin16_Mode==1)&&(Pin16_Task_Number==5)){P16=0;}
1111   2          if((Pin17_Mode==1)&&(Pin17_Task_Number==5)){P17=0;}
1112   2          
1113   2          if((Pin20_Mode==1)&&(Pin20_Task_Number==5)){P20=0;}
1114   2          if((Pin21_Mode==1)&&(Pin21_Task_Number==5)){P21=0;}
1115   2          if((Pin22_Mode==1)&&(Pin22_Task_Number==5)){P22=0;}
1116   2          if((Pin23_Mode==1)&&(Pin23_Task_Number==5)){P23=0;}
1117   2          if((Pin24_Mode==1)&&(Pin24_Task_Number==5)){P24=0;}
1118   2          
1119   2          if((Pin35_Mode==1)&&(Pin35_Task_Number==5)){P35=0;}
1120   2          if((Pin36_Mode==1)&&(Pin36_Task_Number==5)){P36=0;}
1121   2          if((Pin37_Mode==1)&&(Pin37_Task_Number==5)){P37=0;}
1122   2          
1123   2        }else{
1124   2          
1125   2          if((Pin10_Mode==1)&&(Pin10_Task_Number==5)){P10=1;}
1126   2          if((Pin11_Mode==1)&&(Pin11_Task_Number==5)){P11=1;}
1127   2          if((Pin12_Mode==1)&&(Pin12_Task_Number==5)){P12=1;}
1128   2          if((Pin13_Mode==1)&&(Pin13_Task_Number==5)){P13=1;}
1129   2          if((Pin14_Mode==1)&&(Pin14_Task_Number==5)){P14=1;}
1130   2          if((Pin15_Mode==1)&&(Pin15_Task_Number==5)){P15=1;}
1131   2          if((Pin16_Mode==1)&&(Pin16_Task_Number==5)){P16=1;}
1132   2          if((Pin17_Mode==1)&&(Pin17_Task_Number==5)){P17=1;}
1133   2          
1134   2          if((Pin20_Mode==1)&&(Pin20_Task_Number==5)){P20=1;}
1135   2          if((Pin21_Mode==1)&&(Pin21_Task_Number==5)){P21=1;}
1136   2          if((Pin22_Mode==1)&&(Pin22_Task_Number==5)){P22=1;}
1137   2          if((Pin23_Mode==1)&&(Pin23_Task_Number==5)){P23=1;}
1138   2          if((Pin24_Mode==1)&&(Pin24_Task_Number==5)){P24=1;}
1139   2          
1140   2          if((Pin35_Mode==1)&&(Pin35_Task_Number==5)){P35=1;}
1141   2          if((Pin36_Mode==1)&&(Pin36_Task_Number==5)){P36=1;}
1142   2          if((Pin37_Mode==1)&&(Pin37_Task_Number==5)){P37=1;}
1143   2        }   
1144   1      }
1145          
1146          void Task6_Output_Update(void)
1147          {
1148   1          if(Task6 == 1)
1149   1          {
1150   2            switch(Task6_Mode)
1151   2            {
1152   3              case 1:
1153   3                if((Task6_StartTime<=NowTime)&&(NowTime<=Task6_EndTime)
1154   3                  &&(Task5_OverTime_Count<Task5_OverTime)){
1155   4                    Task5_OverTime_Count++;
1156   4                  
1157   4                    if(Task6_OnState==1) //首先如果处于On状态
1158   4                      {
1159   5                        
1160   5                      if(Task6_CountTime<Task6_OnTime){
1161   6                        Task6_CountTime++;
1162   6                        Task6_Output = 1;
1163   6                      }else{
1164   6                        Task6_CountTime = 1;  //复位时间计数器
1165   6                        Task6_OnState = 0; //切换到OFF状态
1166   6                      }
1167   5                      
1168   5                    }else{  //否则处于Off状态
1169   5                      
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 20  

1170   5                      if(Task6_CountTime<Task6_OffTime){
1171   6                        Task6_CountTime++;
1172   6                        Task6_Output = 0;
1173   6                      }else{
1174   6                        Task6_CountTime = 1;  //复位时间计数器
1175   6                        Task6_OnState = 1; //切换到ON状态
1176   6                      }
1177   5                    } 
1178   4                    
1179   4               }else{    //不满足时间运行条件则不输出
1180   4                      
1181   4                        //在时间区间但是任务超时 
1182   4                        //不在时间区间，任务还未超时
1183   4                        //不在时间区间，任务已经超时
1184   4                 
1185   4                 //如果任务六不在时间区间但还没有超时
1186   4                  if(Task6_OverTime_Count<Task6_OverTime){
1187   5                    
1188   5                    Task6_OverTime_Count=0;  //复位超时计数器
1189   5                    Task6_CountTime = 1;  //复位时间计数器
1190   5                    Task6_Output = 0;   //禁止任务6输出
1191   5                    Task6_OnState = 1; //切换到ON状态
1192   5                    
1193   5                    //否则如果任务六已经超时
1194   5                  }else if(Task6_OverTime_Count==Task6_OverTime){
1195   5                    
1196   5                    //使能超时任务自动复位
1197   5                    if(Task6_OverTime_Reset){
1198   6                      
1199   6                      Task6_OverTime_Count=0;  //复位超时计数器
1200   6                                               //如果还在时间区间内将继续运行
1201   6                                               //如果不在时间区间内将等待继续运行
1202   6                    }else{  
1203   6                      
1204   6                      Task6=0; //关闭Task
1205   6                      Task6_OverTime_Count=0;  //复位超时计数器
1206   6                      Task6_CountTime = 1;  //复位时间计数器
1207   6                      Task6_Output = 0;   //禁止任务6输出
1208   6                      Task6_OnState = 1; //切换到ON状态
1209   6                    }
1210   5                    
1211   5                  }
1212   4               }
1213   3               break;
1214   3            }
1215   2          }else{    //任务如果不运行则不输出
1216   2            Task6_OverTime_Count=0;  //复位超时计数器
1217   2            Task6_CountTime = 1;  //复位时间计数器
1218   2            Task6_Output = 0;   //禁止任务6输出
1219   2            Task6_OnState = 1; //切换到ON状态
1220   2          }
1221   1          
1222   1      /******************************************************************************/
1223   1      // 任务六输出处理部分（以此注释向下）
1224   1      /******************************************************************************/
1225   1        if(Task6_Output==1){
1226   2          if((Pin10_Mode==1)&&(Pin10_Task_Number==6)){P10=0;}
1227   2          if((Pin11_Mode==1)&&(Pin11_Task_Number==6)){P11=0;}
1228   2          if((Pin12_Mode==1)&&(Pin12_Task_Number==6)){P12=0;}
1229   2          if((Pin13_Mode==1)&&(Pin13_Task_Number==6)){P13=0;}
1230   2          if((Pin14_Mode==1)&&(Pin14_Task_Number==6)){P14=0;}
1231   2          if((Pin15_Mode==1)&&(Pin15_Task_Number==6)){P15=0;}
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 21  

1232   2          if((Pin16_Mode==1)&&(Pin16_Task_Number==6)){P16=0;}
1233   2          if((Pin17_Mode==1)&&(Pin17_Task_Number==6)){P17=0;}
1234   2          
1235   2          if((Pin20_Mode==1)&&(Pin20_Task_Number==6)){P20=0;}
1236   2          if((Pin21_Mode==1)&&(Pin21_Task_Number==6)){P21=0;}
1237   2          if((Pin22_Mode==1)&&(Pin22_Task_Number==6)){P22=0;}
1238   2          if((Pin23_Mode==1)&&(Pin23_Task_Number==6)){P23=0;}
1239   2          if((Pin24_Mode==1)&&(Pin24_Task_Number==6)){P24=0;}
1240   2          
1241   2          if((Pin35_Mode==1)&&(Pin35_Task_Number==6)){P35=0;}
1242   2          if((Pin36_Mode==1)&&(Pin36_Task_Number==6)){P36=0;}
1243   2          if((Pin37_Mode==1)&&(Pin37_Task_Number==6)){P37=0;}
1244   2          
1245   2        }else{
1246   2          
1247   2          if((Pin10_Mode==1)&&(Pin10_Task_Number==6)){P10=1;}
1248   2          if((Pin11_Mode==1)&&(Pin11_Task_Number==6)){P11=1;}
1249   2          if((Pin12_Mode==1)&&(Pin12_Task_Number==6)){P12=1;}
1250   2          if((Pin13_Mode==1)&&(Pin13_Task_Number==6)){P13=1;}
1251   2          if((Pin14_Mode==1)&&(Pin14_Task_Number==6)){P14=1;}
1252   2          if((Pin15_Mode==1)&&(Pin15_Task_Number==6)){P15=1;}
1253   2          if((Pin16_Mode==1)&&(Pin16_Task_Number==6)){P16=1;}
1254   2          if((Pin17_Mode==1)&&(Pin17_Task_Number==6)){P17=1;}
1255   2          
1256   2          if((Pin20_Mode==1)&&(Pin20_Task_Number==6)){P20=1;}
1257   2          if((Pin21_Mode==1)&&(Pin21_Task_Number==6)){P21=1;}
1258   2          if((Pin22_Mode==1)&&(Pin22_Task_Number==6)){P22=1;}
1259   2          if((Pin23_Mode==1)&&(Pin23_Task_Number==6)){P23=1;}
1260   2          if((Pin24_Mode==1)&&(Pin24_Task_Number==6)){P24=1;}
1261   2          
1262   2          if((Pin35_Mode==1)&&(Pin35_Task_Number==6)){P35=1;}
1263   2          if((Pin36_Mode==1)&&(Pin36_Task_Number==6)){P36=1;}
1264   2          if((Pin37_Mode==1)&&(Pin37_Task_Number==6)){P37=1;}
1265   2        }   
1266   1      }
1267          
1268          /******************************************************************************/
1269          // 函数名称：Task_Output_Update
1270          // 输入参数：无
1271          // 输出参数：无 
1272          // 函数功能：对任务输出进行扫描，用于触发继电器任务
1273          /******************************************************************************/
1274          /*
1275          void Task1_Output_Update(void)
1276          {
1277            if(Task1_Output==1){
1278              if((Pin10_Mode==1)&&(Pin10_Task_Number==1)){P10=0;}
1279              if((Pin11_Mode==1)&&(Pin11_Task_Number==1)){P11=0;}
1280              if((Pin12_Mode==1)&&(Pin12_Task_Number==1)){P12=0;}
1281              if((Pin13_Mode==1)&&(Pin13_Task_Number==1)){P13=0;}
1282              if((Pin14_Mode==1)&&(Pin14_Task_Number==1)){P14=0;}
1283              if((Pin15_Mode==1)&&(Pin15_Task_Number==1)){P15=0;}
1284              if((Pin16_Mode==1)&&(Pin16_Task_Number==1)){P16=0;}
1285              if((Pin17_Mode==1)&&(Pin17_Task_Number==1)){P17=0;}
1286              
1287              if((Pin20_Mode==1)&&(Pin20_Task_Number==1)){P20=0;}
1288              if((Pin21_Mode==1)&&(Pin21_Task_Number==1)){P21=0;}
1289              if((Pin22_Mode==1)&&(Pin22_Task_Number==1)){P22=0;}
1290              if((Pin23_Mode==1)&&(Pin23_Task_Number==1)){P23=0;}
1291              if((Pin24_Mode==1)&&(Pin24_Task_Number==1)){P24=0;}
1292              
1293              if((Pin35_Mode==1)&&(Pin35_Task_Number==1)){P35=0;}
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 22  

1294              if((Pin36_Mode==1)&&(Pin36_Task_Number==1)){P36=0;}
1295              if((Pin37_Mode==1)&&(Pin37_Task_Number==1)){P37=0;}
1296              
1297            }else{
1298              
1299              if((Pin10_Mode==1)&&(Pin10_Task_Number==1)){P10=1;}
1300              if((Pin11_Mode==1)&&(Pin11_Task_Number==1)){P11=1;}
1301              if((Pin12_Mode==1)&&(Pin12_Task_Number==1)){P12=1;}
1302              if((Pin13_Mode==1)&&(Pin13_Task_Number==1)){P13=1;}
1303              if((Pin14_Mode==1)&&(Pin14_Task_Number==1)){P14=1;}
1304              if((Pin15_Mode==1)&&(Pin15_Task_Number==1)){P15=1;}
1305              if((Pin16_Mode==1)&&(Pin16_Task_Number==1)){P16=1;}
1306              if((Pin17_Mode==1)&&(Pin17_Task_Number==1)){P17=1;}
1307              
1308              if((Pin20_Mode==1)&&(Pin20_Task_Number==1)){P20=1;}
1309              if((Pin21_Mode==1)&&(Pin21_Task_Number==1)){P21=1;}
1310              if((Pin22_Mode==1)&&(Pin22_Task_Number==1)){P22=1;}
1311              if((Pin23_Mode==1)&&(Pin23_Task_Number==1)){P23=1;}
1312              if((Pin24_Mode==1)&&(Pin24_Task_Number==1)){P24=1;}
1313              
1314              if((Pin35_Mode==1)&&(Pin35_Task_Number==1)){P35=1;}
1315              if((Pin36_Mode==1)&&(Pin36_Task_Number==1)){P36=1;}
1316              if((Pin37_Mode==1)&&(Pin37_Task_Number==1)){P37=1;}
1317            }
1318            
1319            
1320          }
1321          
1322          */
1323          
1324          /*
1325          void Task2_Output_Update(void)
1326          {
1327            if(Task2_Output==1){
1328              if((Pin10_Mode==1)&&(Pin10_Task_Number==2)){P10=0;}
1329              if((Pin11_Mode==1)&&(Pin11_Task_Number==2)){P11=0;}
1330              if((Pin12_Mode==1)&&(Pin12_Task_Number==2)){P12=0;}
1331              if((Pin13_Mode==1)&&(Pin13_Task_Number==2)){P13=0;}
1332              if((Pin14_Mode==1)&&(Pin14_Task_Number==2)){P14=0;}
1333              if((Pin15_Mode==1)&&(Pin15_Task_Number==2)){P15=0;}
1334              if((Pin16_Mode==1)&&(Pin16_Task_Number==2)){P16=0;}
1335              if((Pin17_Mode==1)&&(Pin17_Task_Number==2)){P17=0;}
1336              
1337              if((Pin20_Mode==1)&&(Pin20_Task_Number==2)){P20=0;}
1338              if((Pin21_Mode==1)&&(Pin21_Task_Number==2)){P21=0;}
1339              if((Pin22_Mode==1)&&(Pin22_Task_Number==2)){P22=0;}
1340              if((Pin23_Mode==1)&&(Pin23_Task_Number==2)){P23=0;}
1341              if((Pin24_Mode==1)&&(Pin24_Task_Number==2)){P24=0;}
1342              
1343              if((Pin35_Mode==1)&&(Pin35_Task_Number==2)){P35=0;}
1344              if((Pin36_Mode==1)&&(Pin36_Task_Number==2)){P36=0;}
1345              if((Pin37_Mode==1)&&(Pin37_Task_Number==2)){P37=0;}
1346              
1347            }else{
1348              
1349              if((Pin10_Mode==1)&&(Pin10_Task_Number==2)){P10=1;}
1350              if((Pin11_Mode==1)&&(Pin11_Task_Number==2)){P11=1;}
1351              if((Pin12_Mode==1)&&(Pin12_Task_Number==2)){P12=1;}
1352              if((Pin13_Mode==1)&&(Pin13_Task_Number==2)){P13=1;}
1353              if((Pin14_Mode==1)&&(Pin14_Task_Number==2)){P14=1;}
1354              if((Pin15_Mode==1)&&(Pin15_Task_Number==2)){P15=1;}
1355              if((Pin16_Mode==1)&&(Pin16_Task_Number==2)){P16=1;}
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 23  

1356              if((Pin17_Mode==1)&&(Pin17_Task_Number==2)){P17=1;}
1357              
1358              if((Pin20_Mode==1)&&(Pin20_Task_Number==2)){P20=1;}
1359              if((Pin21_Mode==1)&&(Pin21_Task_Number==2)){P21=1;}
1360              if((Pin22_Mode==1)&&(Pin22_Task_Number==2)){P22=1;}
1361              if((Pin23_Mode==1)&&(Pin23_Task_Number==2)){P23=1;}
1362              if((Pin24_Mode==1)&&(Pin24_Task_Number==2)){P24=1;}
1363              
1364              if((Pin35_Mode==1)&&(Pin35_Task_Number==2)){P35=1;}
1365              if((Pin36_Mode==1)&&(Pin36_Task_Number==2)){P36=1;}
1366              if((Pin37_Mode==1)&&(Pin37_Task_Number==2)){P37=1;}
1367            }
1368          
1369          } 
1370          
1371          */
1372          
1373          /*
1374          void Task3_Output_Update(void)
1375          {
1376            if(Task3_Output==1){
1377              if((Pin10_Mode==1)&&(Pin10_Task_Number==3)){P10=0;}
1378              if((Pin11_Mode==1)&&(Pin11_Task_Number==3)){P11=0;}
1379              if((Pin12_Mode==1)&&(Pin12_Task_Number==3)){P12=0;}
1380              if((Pin13_Mode==1)&&(Pin13_Task_Number==3)){P13=0;}
1381              if((Pin14_Mode==1)&&(Pin14_Task_Number==3)){P14=0;}
1382              if((Pin15_Mode==1)&&(Pin15_Task_Number==3)){P15=0;}
1383              if((Pin16_Mode==1)&&(Pin16_Task_Number==3)){P16=0;}
1384              if((Pin17_Mode==1)&&(Pin17_Task_Number==3)){P17=0;}
1385              
1386              if((Pin20_Mode==1)&&(Pin20_Task_Number==3)){P20=0;}
1387              if((Pin21_Mode==1)&&(Pin21_Task_Number==3)){P21=0;}
1388              if((Pin22_Mode==1)&&(Pin22_Task_Number==3)){P22=0;}
1389              if((Pin23_Mode==1)&&(Pin23_Task_Number==3)){P23=0;}
1390              if((Pin24_Mode==1)&&(Pin24_Task_Number==3)){P24=0;}
1391              
1392              if((Pin35_Mode==1)&&(Pin35_Task_Number==3)){P35=0;}
1393              if((Pin36_Mode==1)&&(Pin36_Task_Number==3)){P36=0;}
1394              if((Pin37_Mode==1)&&(Pin37_Task_Number==3)){P37=0;}
1395              
1396            }else{
1397              
1398              if((Pin10_Mode==1)&&(Pin10_Task_Number==3)){P10=1;}
1399              if((Pin11_Mode==1)&&(Pin11_Task_Number==3)){P11=1;}
1400              if((Pin12_Mode==1)&&(Pin12_Task_Number==3)){P12=1;}
1401              if((Pin13_Mode==1)&&(Pin13_Task_Number==3)){P13=1;}
1402              if((Pin14_Mode==1)&&(Pin14_Task_Number==3)){P14=1;}
1403              if((Pin15_Mode==1)&&(Pin15_Task_Number==3)){P15=1;}
1404              if((Pin16_Mode==1)&&(Pin16_Task_Number==3)){P16=1;}
1405              if((Pin17_Mode==1)&&(Pin17_Task_Number==3)){P17=1;}
1406              
1407              if((Pin20_Mode==1)&&(Pin20_Task_Number==3)){P20=1;}
1408              if((Pin21_Mode==1)&&(Pin21_Task_Number==3)){P21=1;}
1409              if((Pin22_Mode==1)&&(Pin22_Task_Number==3)){P22=1;}
1410              if((Pin23_Mode==1)&&(Pin23_Task_Number==3)){P23=1;}
1411              if((Pin24_Mode==1)&&(Pin24_Task_Number==3)){P24=1;}
1412              
1413              if((Pin35_Mode==1)&&(Pin35_Task_Number==3)){P35=1;}
1414              if((Pin36_Mode==1)&&(Pin36_Task_Number==3)){P36=1;}
1415              if((Pin37_Mode==1)&&(Pin37_Task_Number==3)){P37=1;}
1416            }
1417          
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 24  

1418          }
1419          
1420          */
1421          
1422          /*
1423          void Task4_Output_Update(void)
1424          {
1425            if(Task4_Output==1){
1426              if((Pin10_Mode==1)&&(Pin10_Task_Number==4)){P10=0;}
1427              if((Pin11_Mode==1)&&(Pin11_Task_Number==4)){P11=0;}
1428              if((Pin12_Mode==1)&&(Pin12_Task_Number==4)){P12=0;}
1429              if((Pin13_Mode==1)&&(Pin13_Task_Number==4)){P13=0;}
1430              if((Pin14_Mode==1)&&(Pin14_Task_Number==4)){P14=0;}
1431              if((Pin15_Mode==1)&&(Pin15_Task_Number==4)){P15=0;}
1432              if((Pin16_Mode==1)&&(Pin16_Task_Number==4)){P16=0;}
1433              if((Pin17_Mode==1)&&(Pin17_Task_Number==4)){P17=0;}
1434              
1435              if((Pin20_Mode==1)&&(Pin20_Task_Number==4)){P20=0;}
1436              if((Pin21_Mode==1)&&(Pin21_Task_Number==4)){P21=0;}
1437              if((Pin22_Mode==1)&&(Pin22_Task_Number==4)){P22=0;}
1438              if((Pin23_Mode==1)&&(Pin23_Task_Number==4)){P23=0;}
1439              if((Pin24_Mode==1)&&(Pin24_Task_Number==4)){P24=0;}
1440              
1441              if((Pin35_Mode==1)&&(Pin35_Task_Number==4)){P35=0;}
1442              if((Pin36_Mode==1)&&(Pin36_Task_Number==4)){P36=0;}
1443              if((Pin37_Mode==1)&&(Pin37_Task_Number==4)){P37=0;}
1444              
1445            }else{
1446              
1447              if((Pin10_Mode==1)&&(Pin10_Task_Number==4)){P10=1;}
1448              if((Pin11_Mode==1)&&(Pin11_Task_Number==4)){P11=1;}
1449              if((Pin12_Mode==1)&&(Pin12_Task_Number==4)){P12=1;}
1450              if((Pin13_Mode==1)&&(Pin13_Task_Number==4)){P13=1;}
1451              if((Pin14_Mode==1)&&(Pin14_Task_Number==4)){P14=1;}
1452              if((Pin15_Mode==1)&&(Pin15_Task_Number==4)){P15=1;}
1453              if((Pin16_Mode==1)&&(Pin16_Task_Number==4)){P16=1;}
1454              if((Pin17_Mode==1)&&(Pin17_Task_Number==4)){P17=1;}
1455              
1456              if((Pin20_Mode==1)&&(Pin20_Task_Number==4)){P20=1;}
1457              if((Pin21_Mode==1)&&(Pin21_Task_Number==4)){P21=1;}
1458              if((Pin22_Mode==1)&&(Pin22_Task_Number==4)){P22=1;}
1459              if((Pin23_Mode==1)&&(Pin23_Task_Number==4)){P23=1;}
1460              if((Pin24_Mode==1)&&(Pin24_Task_Number==4)){P24=1;}
1461              
1462              if((Pin35_Mode==1)&&(Pin35_Task_Number==4)){P35=1;}
1463              if((Pin36_Mode==1)&&(Pin36_Task_Number==4)){P36=1;}
1464              if((Pin37_Mode==1)&&(Pin37_Task_Number==4)){P37=1;}
1465            }
1466          
1467          }
1468          */
1469          
1470          
1471          
1472          
1473          
1474          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5583    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.60.0.0   RELAY                                                             07/31/2022 23:33:24 PAGE 25  

   XDATA SIZE       =    166    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     48    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
